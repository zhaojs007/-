一）什么是虚拟化？

    虚拟化的含义是非常广泛的，只要是单独的物理资源变成共享的物理资源都可以称之为虚拟化技术。比如说OS中内存的虚拟化，CPU的虚拟化等等。这里不讨论进程级也可以说是APP层的虚拟化。站在计算机系统的角度来说，物理资源大体分为：计算资源（CPU）、存储资源（内存）、外设资源（IO）。后续我们也将会从这三个角度来学习虚拟化技术。
    在CPU不够快、内存资源不够多、外设不够强的背景下，虚拟化技术主要是用来解决多用户、多进程的共享技术，比如说OS中的分页技术，IO设备中的Spooling技术等。随后由于CPU、内存等物理资源的飞速发展使得虚拟机这类特殊的进程得到开发者的喜爱，促进了虚拟化技术的发展，能够实现在一台物理机上可以模拟出多台虚拟机（Virtual Machine，VM），每一个虚机都可以安装自己独立的操作系统（Guest os）。提供虚拟化的平台称为VMM（Virtual Machine Monitor）。根据虚拟化实现的机制不同，可以将虚拟化技术分为安全虚拟化和类虚拟技术。

二）虚拟化分为：完全虚拟化/类虚拟化

    完全虚拟化：
    如果Guest OS不做任何修改就可以直接运行在VMM上，不感知自己运行在一个虚拟化环境中，这种方式称之为“完全虚拟化”技术。在这种模式下，VMM需要正确处理Guest OS需要执行的所有指令。那么最简单的方式就是对Guest os中每一条执行的指令进行模拟（解释、执行），将最终结果返回给虚机。这种方式既适用于和HOST同系统结构的Guest os也适用于和HOST不同体系结构的Guest os（比如说HOST是x86，Guest os可以是ARM或者MAC OS等）。这种通用的做法会带来性能的急剧下降。然而，有一些特权指令，比如说与IO设备有关的指令、读写中断寄存器等等这些是没法直接在物理CPU上进行运行返回结果。这时就需要VMM的参与将敏感指令和对特权资源的访问进行截获、模拟。
    
    类虚拟化：
    x86这种CISC架构的系统，指令复杂，其中一些指令很难虚拟化，如果采用完全虚拟化方式，就需要通过二级制代码翻译（binary translation）。大体过程就是扫描并修改Guest的二进制代码，将难以虚拟化的指令转化成支持虚拟化的指令，这个过程铁定是非常耗时的。
    如果是直接修改Guest os的内核代码，就可以使内核避免产生这些难以虚拟化的指令，这就是“类虚拟化”技术产生的原因。
    
三）主流模型

    Hypervisor模型
    在hypervisor模型中，VMM是一个完整的操作系统，它除了具备传统操作系统的功能之外，还具备虚拟化功能。由于需要将物理资源进行虚拟化，所以包括CPU、内存和IO设备在内的所有的物理资源都归VMM所有，对于CPU调度、页面调度等还是归传统操作系统控制管理。
    ![image](https://github.com/zhaojs007/Virtualization_Tech-Study/blob/main/Virtualization_pictures/hypervisor.jpg)
    该模型是比较高效的，然而缺点也是很明显的，即IO设备种类繁多，管理所有的设备需要大量的驱动开发工作。（由于内核做了修改，开发商提供的驱动程序大部分是基于现有OS（比如说centos、ubuntu等）系统的驱动，需要大量的适配工作等）
    
    Host模型（宿主机模型）
    在Host模型中，物理资源是由传统OS来掌管，由于传统OS并不完全是为了虚拟化而设计的，因此实际的虚拟化功能需要VMM来提供。根据VMM要做的事情，VMM定位应该是Host OS中内核模块的一部分。为了获取物理资源，这就需要通过调用传统OS的服务来获取相应的信息，实现CPU、内存、IO设备的虚拟化。因此，VMM创建出虚机之后，通常将虚机作为host os的一个进程参与调度管理。
    ![image](https://github.com/zhaojs007/Virtualization_Tech-Study/blob/main/Virtualization_pictures/host-module.jpg)
    
    Host模型最大的优点就是可以充分利用现有操作系统的设备驱动程序，VMM不需要为各种IO设备重新实现驱动，可以更加专注于物理资源虚拟化的优化工作。缺点也是明显的，由于虚拟化过程中需要HOST OS提供服务，从而可能导致硬件利用不充分。
    从架构上看，KVM(Kernel-based Virtual Machine)就是属于HOST模型。

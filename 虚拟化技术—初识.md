一）什么是虚拟化？

    虚拟化的含义是非常广泛的，只要是单独的物理资源变成共享的物理资源都可以称之为虚拟化技术。比如说OS中内存的虚拟化，CPU的虚拟化等等。这里不讨论进程级也可以说是APP层的虚拟化。站在计算机系统的角度来说，物理资源大体分为：计算资源（CPU）、存储资源（内存）、外设资源（IO）。后续我们也将会从这三个角度来学习虚拟化技术。
    在CPU不够快、内存资源不够多、外设不够强的背景下，虚拟化技术主要是用来解决多用户、多进程的共享技术，比如说OS中的分页技术，IO设备中的Spooling技术等。随后由于CPU、内存等物理资源的飞速发展使得虚拟机这类特殊的进程得到开发者的喜爱，促进了虚拟化技术的发展，能够实现在一台物理机上可以模拟出多台虚拟机（Virtual Machine，VM），每一个虚机都可以安装自己独立的操作系统（Guest os）。提供虚拟化的平台称为VMM（Virtual Machine Monitor）。根据虚拟化实现的机制不同，可以将虚拟化技术分为安全虚拟化和类虚拟技术。

二）虚拟化分类：完全虚拟化/类虚拟化

    完全虚拟化：
    如果Guest OS不做任何修改就可以直接运行在VMM上，不感知自己运行在一个虚拟化环境中，这种方式称之为“完全虚拟化”技术。在这种模式下，VMM需要正确处理Guest OS需要执行的所有指令。那么最简单的方式就是对Guest os中每一条执行的指令进行模拟（解释、执行），将最终结果返回给虚机。这种方式既适用于和HOST同系统结构的Guest os也适用于和HOST不同体系结构的Guest os（比如说HOST是x86，Guest os可以是ARM或者MAC OS等）。这种通用的做法会带来性能的急剧下降。然而，有一些特权指令，比如说与IO设备有关的指令、读写中断寄存器等等这些是没法直接在物理CPU上进行运行返回结果。这时就需要VMM的参与将敏感指令和对特权资源的访问进行截获、模拟。
    
    类虚拟化：
    x86这种CISC架构的系统，指令复杂，其中一些指令很难虚拟化，如果采用完全虚拟化方式，就需要通过二级制代码翻译（binary translation）。大体过程就是扫描并修改Guest的二进制代码，将难以虚拟化的指令转化成支持虚拟化的指令，这个过程铁定是非常耗时的。
    如果是直接修改Guest os的内核代码，就可以使内核避免产生这些难以虚拟化的指令，这就是“类虚拟化”技术产生的原因。
    
三）主流模型

    Hypervisor模型
    在hypervisor模型中，VMM是一个完整的操作系统，它除了具备传统操作系统的功能之外，还具备虚拟化功能。由于需要将物理资源进行虚拟化，所以包括CPU、内存和IO设备在内的所有的物理资源都归VMM所有，对于CPU调度、页面调度等还是归传统操作系统控制管理。
    ![image](https://github.com/zhaojs007/Virtualization_Tech-Study/blob/main/Virtualization_pictures/hypervisor.jpg)
    该模型是比较高效的，然而缺点也是很明显的，即IO设备种类繁多，管理所有的设备需要大量的驱动开发工作。（由于内核做了修改，开发商提供的驱动程序大部分是基于现有OS（比如说centos、ubuntu等）系统的驱动，需要大量的适配工作等）
    
    Host模型（宿主机模型）
    在Host模型中，物理资源是由传统OS来掌管，由于传统OS并不完全是为了虚拟化而设计的，因此实际的虚拟化功能需要VMM来提供。根据VMM要做的事情，VMM定位应该是Host OS中内核模块的一部分。为了获取物理资源，这就需要通过调用传统OS的服务来获取相应的信息，实现CPU、内存、IO设备的虚拟化。因此，VMM创建出虚机之后，通常将虚机作为host os的一个进程参与调度管理。
    ![image](https://github.com/zhaojs007/Virtualization_Tech-Study/blob/main/Virtualization_pictures/host-module.jpg)
    
    Host模型最大的优点就是可以充分利用现有操作系统的设备驱动程序，VMM不需要为各种IO设备重新实现驱动，可以更加专注于物理资源虚拟化的优化工作。缺点也是明显的，由于虚拟化过程中需要HOST OS提供服务，从而可能导致硬件利用不充分。
    从架构上看，KVM(Kernel-based Virtual Machine)就是属于HOST模型。随着越来愈多的虚拟化功能加入到linux内核中，使得Linux内核看起来越来越像Hypervisor架构。
    
    混合模型
    
    在混合模型中，VMM依然掌控所有的物理资源，但为了充分利用现有操作系统的IO驱动，VMM将大部分的IO设备交给一个运行在特权级的虚拟操作系统中（Service OS）来处理，而VMM主要负责CPU和内存的管理控制。
    ![iamge](https://github.com/zhaojs007/Virtualization_Tech-Study/blob/main/Virtualization_pictures/mixed-model.jpg)
    尽管看起来，似乎混合模型结合了上述模型的优势，既不用另外开发IO设备的驱动，又可以直接管理物理资源。但是由于Service OS的引入，这无疑增加了上下文的开销。
    
四）实现思路

    传统的x86架构的运行模式有4种，从ring 0到ring 3，ring 0是最高特权级，通常用于OS内核。ring 3是最低优先级的，通常用于APP。ring 1最初的设计是用来运行驱动程序的，但是在使用宏内核的linux中，驱动程序也和内核一样运行于ring 0级别的，因而ring 1和ring2通常不被使用的。
    
    （这里补充一下小插曲：借用一下网上对于微内核和宏内核的定义：
    微内核：内核管理着所有的系统资源，在微内核中用户服务和内核服务在不同的地址空间中实现。在应用程序和硬件的通信中，内核进程和内存管理的极小的服务，而客户端程序和运行在用户空间的服务通过消息的传递来建立通信，它们之间不会有直接的交互，这样一来，微内核中的执行速度相对就比较慢了，这是微内核架构的一个缺点。 在内核架构中，用户服务是独立于内核服务的，因此任何用户服务崩溃都不会影响到内核服务，这就加强了操作系统的健壮性，这是微内核的优势所在。另一点，微内核的扩展性强，添加一个功能，只需要建立一个新的服务到用户空间当中，而内核空间不需要任何的修改。因此，微内核可移植性强、安全并且易于扩展。（有FPGA和驱动联调的经历会对此点深有体会的）
    宏内核：宏内核同样管理着用户程序和硬件之间的系统资源，但是和微内核不一样的是，在宏内核架构中，用户服务和内核服务在同一空间中实现。具体一点，就是内核可以代表内核进程运行代码，就是通常的内核进程；当用户进程经过系统调用或者中断进入到内核态时，内核也可以代表它运行代码。这样一来，宏内核需要管理的资源多于微内核，其大小就相对大一些了。在宏内核架构当中，内核管理着CPU调度，内存管理，文件管理和系统调用等各模块的的工作，由于用户服务和内核服务被实现在同一空间中，这样在执行速度上要比微内核快。然而，宏内核的劣势也是显而易见的，那就是当内核中的某个服务崩溃了，整个内核也会崩溃。另一点，想要在内核中添加新的功能就意味着内核中的各个模块需要做相应的修改，因此其扩展性很弱。）
    
    言归正传，在KVM版本中
